<html>
    <head>
        <script
            type="text/javascript"
            src="../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
require_once(&quot;DacuraSession.php&quot;);
require_once(&quot;UserRole.php&quot;);

/**
 * Class representing user of the Dacura System
 * 
 * User Object contains user roles and sessions
 * * Creation Date: 20/11/2014
 * 
 * @author Chekov
 * @License GPL v2
 */
class DacuraUser extends DacuraObject {
	/** @var string the users email address */
	var $email;
	/** @var string the users name */
	var $name;
	/** @var string the users handle is the user's name if it is set, email address otherwise*/
	var $handle;
	/** @var array name-value profile settings for the user */
	var $profile;
	/** @var array an array of DacuraSession objects, indexed by collection ids, representing current user sessions */
	var $sessions = array(); 
	/** @var array an array of DacuraSession objects representing historical user sessions */
	var $history = array(); 
	/** @var array the list of roles that this user possesses */
	var $roles = array();

	/**
	 * 
	 * @param number $id the id of the user
	 * @param string $e the user's email address
	 * @param string $n the user's name 
	 * @param string $status one of DacuraObject::$valid_statuses
	 * @param array $prof a name-value array of profile settings 
	 */
	function __construct($id, $e, $n, $status, $prof = &quot;&quot;){
		$this-&gt;id = $id;
		$this-&gt;email = $e;
		$this-&gt;name = $n;
		$this-&gt;status = $status;
		$this-&gt;profile = $prof;
		$this-&gt;handle = ($this-&gt;name) ? $this-&gt;name : $this-&gt;email;
	}
	
	/**
	 * Returns the name of the user 
	 * @return string username
	 */
	function getName(){
		return $this-&gt;handle;
	}
	
	/**
	 * Removes fields of the object that are not to be sent over the api 
	 * @see DacuraObject::forapi()
	 */
	function forapi(){
		parent::forapi();
		unset($this-&gt;sessions);
		unset($this-&gt;history);
		return $this; 
	}
	
	/**
 	 * Does the user have the god role for the given collection?
	 * @param string $cid collection id for which the question is asked
	 * @return boolean true if the user has the god role
	 */
	function isGod($cid = &quot;all&quot;){
		foreach($this-&gt;roles as $r){
			if($r-&gt;isGod() &amp;&amp; ($r-&gt;cid() == $cid || $r-&gt;cid() == &quot;all&quot;)) return true;
		}
		return false;
	}
	
	/**
	 * Is the user an admin of the collection?
	 * @param string $cid the collection id
	 * @return boolean true if the user is an admin
	 */
	function isCollectionAdmin($cid){
		return $this-&gt;hasCollectionRole($cid, &quot;admin&quot;);
	}
	
	/**
	 * Does the user have a role in the collection
	 * @param string $cid collection id
	 * @param string $role minimum role required (defaults to nobody)
	 * @return boolean true if the user has a collection role that is equal or greater to the passed role
	 */
	function hasCollectionRole($cid, $role = false){
		$role = $role ? $role : &quot;nobody&quot;;
		foreach($this-&gt;roles as $r){
			if($r-&gt;covers($role, $cid)){
				return true;				
			}
		}
		return false;
	}
	
	/**
	 * Has the user got the minimum role (or greater) in the collection 
	 * 
	 * This is just a synonym of hasCollectionRole
	 * @param string $minimum_role
	 * @param string $collection_id
	 * @return boolean
	 */
	function hasSufficientRole($minimum_role, $collection_id){
		return $this-&gt;hasCollectionRole($collection_id, $minimum_role);
	}
	
	/**
	 * Fetches a list of all the collection ids in which the user has 'admin' role
	 * @return string[] a list of the administered collection ids
	 */
	function getAdministeredCollections(){
		$cids = array();
		foreach($this-&gt;roles as $r){
			if(($r-&gt;isGod() || $r-&gt;isAdmin()) &amp;&amp; $r-&gt;collection_id != &quot;&quot; &amp;&amp; $r-&gt;collection_id != &quot;all&quot;){
				if(!in_array($r-&gt;collection_id, $cids)) $cids[] = $r-&gt;collection_id;
			}
		}
		return $cids;
	}

	/**
	 * Fetches a list of all the collection ids in which the user has a role
	 * @return string[] a list of the collection ids that they user has a role in
	 */
	function getCollectionsWithRole(){
		$cids = array();
		foreach($this-&gt;roles as $r){
			if($r-&gt;collection_id != &quot;&quot; &amp;&amp; $r-&gt;collection_id != &quot;all&quot;){
				if(!in_array($r-&gt;collection_id, $cids)) $cids[] = $r-&gt;collection_id;
			}
		}
		return $cids;
	}
	
	/**
	 * Add a new role to the user
	 * @param UserRole $r
	 */
	function addRole($r){
		$this-&gt;roles[] = $r;
	}

	/**
	 * Return a particular role object
	 * @param string $rid the role id
	 * @return UserRole|boolean
	 */
	function getRole($rid){
		foreach($this-&gt;roles as $i =&gt; $role){
			if($role-&gt;id == $rid){
				return $role;
			}
		}
		return $this-&gt;failure_result(&quot;User $this-&gt;id does not have a role with id $rid&quot;, 404);
	}
	
	/**
	 * Does the user have roles in more than one collection?
	 * @param string $role the minimum role required
	 * @return boolean true if the user has the minimum role or greater in more than one collection
	 */
	function rolesSpanCollections($role = false){
		if($this-&gt;isGod()) return true;
		if(count($this-&gt;roles) == 0) return false;
		$r1 = $this-&gt;roles[0];
		$r1c = $r1-&gt;cid();
		foreach($this-&gt;roles as $r){
			if($r-&gt;cid() == &quot;all&quot;) return true;
			if($r-&gt;cid() != $r1c &amp;&amp; (!$role or $role == $r-&gt;role)) return true;
		}
		return false;
	}
	
	/**
	 * Which is the collection id of the user's primary role?
	 * @return string the collection id
	 */
	function getRoleCollectionId(){
		if(count($this-&gt;roles) &lt; 1) return false;
		$r1 = $this-&gt;roles[0];
		return $r1-&gt;cid();
	}
	
	/**
	 * Returns an array of the roles that the user has in the given collection id
	 * @param string $cid
	 * @return array&lt;string&gt; the role names that the user has in the collections
	 */
	function getRolesInCollection($cid){
		$roles = array();
		foreach($this-&gt;roles as $i =&gt; $role){
			if($role-&gt;cid() == $cid &amp;&amp; !in_array($role-&gt;role(), $roles)){
				$roles[] = $role-&gt;role();
			}
		}
		return $roles;
	}
	
	/**
	 * Returns a structure summarising the set of roles possessed by the user
	 * 
	 * 
	 */
	function roleSummary(){
		$roles = array();
		foreach($this-&gt;roles as $i =&gt; $role){
			if(!isset($roles[$role-&gt;role()])){
				$roles[$role-&gt;role()] = UserRole::$dacura_roles[$role-&gt;role()] . &quot; in &quot;.$role-&gt;cid();
			}
			else {
				$roles[$role-&gt;role()] .= &quot;, &quot;.$role-&gt;cid();
			}
		}
		return $roles;
	}
	
	function collectionSummary(){
		$collections = array();
		foreach($this-&gt;roles as $id =&gt; $role){
			if(!isset($collections[$role-&gt;cid()])){
				$collections[$role-&gt;cid()] = array();
			}
			if(!isset($collections[$role-&gt;cid()][$role-&gt;role()])){
				$collections[$role-&gt;cid()][] = UserRole::$dacura_roles[$role-&gt;role()];
			}				
		}
		return $collections;		
	}
	
	
	/**
	 * What category is the user
	 * 
	 * Users are divided into categories depending on the distribution of roles that they have
	 */
	function rcategory(){
		if($this-&gt;isGod(&quot;all&quot;)) return &quot;god&quot;; 
		if($this-&gt;isCollectionAdmin(&quot;all&quot;)) return &quot;platform administrator&quot;;
		if($this-&gt;hasCollectionRole(&quot;all&quot;, &quot;user&quot;)) return &quot;platform user&quot;;
		if($this-&gt;rolesSpanCollections(&quot;user&quot;)) return &quot;multi-collection user&quot;;
		$cid = $this-&gt;getRoleCollectionId();
		if(!$cid){
			return &quot;zombie&quot;;
		}
		if($cid == &quot;all&quot;){//role must be nobody
			return &quot;platform slave&quot;;
		}
		if($this-&gt;isCollectionAdmin($cid)){
			return &quot;collection administrator&quot;;
		}
		if($this-&gt;hasCollectionRole($cid, &quot;user&quot;)){
			return &quot;collection user&quot;;
		}
		if($this-&gt;rolesSpanCollections()){ //must be nobody
			return &quot;multi-collection slave&quot;;
		}
		if($this-&gt;hasCollectionRole($cid, &quot;nobody&quot;)){
			return &quot;collection slave&quot;;
		}
		return &quot;banjaxed&quot;;		
	}
	
	function isPlatformAdmin(){
		$x = $this-&gt;rcategory();
		return ($x == &quot;platform administrator&quot; || $x == &quot;god&quot;);
	}

	function isPlatformUser(){
		$x = $this-&gt;rcategory();
		return ($x == &quot;platform user&quot;);
	}	
	
	/* Session Management Functions */


	/**
	 * Creates a new session and optionally starts it
	 * @param string $sid session id
	 * @param string $cid the collection id in which the session is taking place
	 * @param boolean $autostart if set to true, the session will start immediately
	 * @return boolean true if the session was created ok
	 */
	function createSession($sid, $cid, $autostart=true){
		if(!isset($this-&gt;sessions[$cid])){
			$this-&gt;sessions[$cid] = array();					
		}
		if(!isset($this-&gt;sessions[$cid][$sid])){
			$this-&gt;sessions[$cid][$sid] = new DacuraSession($sid, $cid, $autostart);
		}
		else {
			$this-&gt;sessions[$cid][$sid]-&gt;registerEvent(array(&quot;action&quot; =&gt; &quot;abort&quot;));
			$this-&gt;dumpSession($sid, $cid);
			$this-&gt;sessions[$cid][$sid] = new DacuraSession($sid, $cid, $autostart);
		}
		return true;
	}
	
	/**
	 * Ends a session
	 * @param string $sid session id
	 * @param string $cid the collection id in which the session is taking place
	 * @param string $action the action which is terminating the session (abort | end)
	 * @return boolean true if session ended ok
	 */
	public function endSession($sid, $cid, $action = &quot;end&quot;){
		if(isset($this-&gt;sessions[$cid][$sid])){
			$this-&gt;sessions[$cid][$sid]-&gt;registerEvent(array(&quot;action&quot; =&gt; $action));
			$this-&gt;dumpSession($sid, $cid);
			unset($this-&gt;sessions[$cid][$sid]);
			return true;
		}
		return false;
	}
	
	/**
	 * Writes the session to file (normally because it is complete)
	 * @param string $sid session id
	 * @param string $cid the collection id in which the session is taking place
	 * @return boolean true on success
	 */
	private function dumpSession($sid, $cid){
		if(!isset($this-&gt;sessions[$cid][$sid])){
			return $this-&gt;failure_result(&quot;No session to dump session $sid in collection $cid does not exist&quot;, 404);
		}
		//this is bad - we use the global dacura-server object to get our path to the dump file
		//this is so that we don't have to pass the server object all the way along to the user object
		global $dacura_server;
		$sdir = $dacura_server-&gt;getSystemSetting(&quot;path_to_collections&quot;).$cid.&quot;/sessions/&quot;.$this-&gt;id;
		if(!file_exists($sdir)){
			if(!mkdir($sdir, 0777, true)){
				return $this-&gt;failure_result(&quot;User session dump directory $sdir does not exist and could not be created - check file permissions to ensure that the webserver can write to that directory&quot;, 500);
			}			
		}
		//now we just append to the service session file, creating the file if it does not exist
		$sfile = $sdir.&quot;/&quot;.$sid.&quot;.session&quot;;
		$srecord = json_encode($this-&gt;sessions[$cid][$sid]-&gt;events);
		if(!file_put_contents($sfile, $srecord.&quot;\n&quot;, FILE_APPEND | LOCK_EX)){
			return $this-&gt;failure_result(&quot;Failed to write session $sid in collection $cid to dump file&quot;, 500);
		}
		return true;				
	}
	
	/**
	 * Pauses a session
	 * @param string $sid session id
	 * @param string $cid the collection id in which the session is taking place
	 * @return boolean true on success
	 */
	public function pauseSession($sid, $cid){
		if(isset($this-&gt;sessions[$cid][$sid])){
			$this-&gt;sessions[$cid][$sid]-&gt;pause();
			return true;
		}
		return $this-&gt;failure_result(&quot;No session $sid in collection $cid to pause&quot;, 404);
	}

	/**
	 * Unpause the session - make it active
	 * @param string $sid session id
	 * @param string $cid the collection id in which the session is taking place
	 * @return boolean true on success
	 */
	public function unpauseSession($sid, $cid){
		if(isset($this-&gt;sessions[$cid][$sid])){
			$this-&gt;sessions[$cid][$sid]-&gt;unpause();
			return true;
		}
		return $this-&gt;failure_result(&quot;No session $sid in collection $cid to unpause&quot;, 404);
	}
	
	/**
	 * Gets the details of the session 
	 * 
	 * This assumes a session model where entities are assigned to the user, then rejected or accepted.
	 * @param string $sid session id
	 * @param string $cid the collection id in which the session is taking place
	 * @return array with [duration: secs, assigned: n, accepted: n, rejected: n] where n is the count of entities
	 */
	public function getSessionDetails($sid, $cid){
		if(isset($this-&gt;sessions[$cid][$sid])){
			$s = $this-&gt;sessions[$cid][$sid];
			$res = array(&quot;duration&quot; =&gt; gmdate(&quot;H:i:s&quot;, $s-&gt;activeDuration()),
					&quot;assigned&quot; =&gt; $s-&gt;eventCount(&quot;assign&quot;), 
					&quot;accepted&quot; =&gt; $s-&gt;eventCount(&quot;accept&quot;), 
					&quot;rejected&quot;=&gt; $s-&gt;eventCount(&quot;reject&quot;));
			return $res;
		}
		return $this-&gt;failure_result(&quot;session $sid in collection $cid does not exist - no details available&quot;, 404);
	}
	
	/**
	 * Records a particular user action to the session
	 * @param string $sid session id
	 * @param string $cid the collection id in which the session is taking place
	 * @param string $type the type of action 
	 * @param boolean $dump if true, the session will be saved to file
	 */
	public function recordAction($sid, $cid, $type, $dump = false){
		if(!isset($this-&gt;sessions[$cid])){
			$this-&gt;sessions[$cid] = array();
		}
		if(!isset($this-&gt;sessions[$cid][$sid])){
			$this-&gt;sessions[$cid][$sid] = new DacuraSession($sid, $cid);
		}
		$this-&gt;sessions[$cid][$sid]-&gt;registerEvent(array(&quot;action&quot; =&gt; $type));
		if($dump){
			$this-&gt;dumpSession($sid, $cid);
			unset($this-&gt;sessions[$cid][$sid]);
		}
	}	
	
	/**
	 * Register a particular event with a session
	 * @param string $sid session id
	 * @param string $cid the collection id in which the session is taking place
	 * @param array $ev an event description array [action: myaction...]
	 */
	public function registerSessionEvent($sid, $cid, $ev){
		if(!isset($this-&gt;sessions[$cid])){
			$this-&gt;sessions[$cid] = array();
		}
		if(!isset($this-&gt;sessions[$cid][$sid])){
			$this-&gt;sessions[$cid][$sid] = new DacuraSession($sid, $cid);
		}
		$this-&gt;sessions[$cid][$sid]-&gt;registerEvent($ev);
	}
	
	/**
	 * Does the user have any live sessions?
	 * @param string $sid session id
	 * @param string $cid the collection id in which the session is taking place
	 * @return boolean
	 */
	function hasLiveSession($sid, $cid){
		return (isset($this-&gt;sessions[$cid]) &amp;&amp; isset($this-&gt;sessions[$cid][$sid]) ? $this-&gt;sessions[$cid][$sid]-&gt;hasLiveSession() : false); 
	}
	
	/**
	 * Terminates all a user's live sessions
	 * @param string $action the action that cause the session termination
	 */
	function endLiveSessions($action){
		foreach($this-&gt;sessions as $cid =&gt; $sesses){
			foreach($sesses as $sid =&gt; $sess){
				$this-&gt;endSession($sid, $cid, $action);
				$this-&gt;dumpSession($sid, $cid);
				unset($this-&gt;sessions[$cid][$sid]);				
			}
		}
	}
	/**
	 * Unsets the entity that is currently assigned to the user's session
	 * @param string $sid session id
	 * @param string $cid the collection id in which the session is taking place
	 */
	function unsetCurrentEntity($sid, $cid){
		if(isset($this-&gt;sessions[$cid][$sid])){
			$this-&gt;sessions[$cid][$sid]-&gt;current_entity = null;
		}
	}
}




</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>