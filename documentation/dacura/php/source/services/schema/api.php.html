<html>
    <head>
        <script
            type="text/javascript"
            src="../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
getRoute()-&gt;post('/import', 'import_ontology');
getRoute()-&gt;get('/(\w+)/dependencies', 'calculate_dependencies');
getRoute()-&gt;post('/validate_ontologies', 'validate_ontologies');

getRoute()-&gt;get('/structure', 'get_entity_classes');
//getRoute()-&gt;get('/structure/(\w+)', 'get_entity_classes');//with graph id
//getRoute()-&gt;get('/structure/(\w+)/(.+)', 'get_class_template');//with graph id

function import_ontology(){
	global $dacura_server;
	$dacura_server-&gt;init(&quot;import_ontology&quot;);
	if(!isset($_POST['format'])){
		$payload = file_get_contents('php://input');
		$format = &quot;upload&quot;;
		$entid = (isset($_GET['id']) &amp;&amp; $_GET['id']) ? $_GET['id']: &quot;&quot;;
		$enttitle = (isset($_GET['title']) &amp;&amp; $_GET['title']) ? $_GET['title']: &quot;&quot;;
		$enturl = (isset($_GET['url']) &amp;&amp; $_GET['url']) ? $_GET['url']: &quot;&quot;;
	}
	else {
		$payload = isset($_POST['payload']) ? $_POST['payload'] : &quot;&quot;;
		$format = isset($_POST['format']) ? $_POST['format'] : &quot;&quot;;
		$entid = isset($_POST['id']) ? $_POST['id'] : &quot;&quot;;
		$enturl = isset($_POST['url']) ? $_POST['url'] : &quot;&quot;;
		$enttitle = isset($_POST['title']) ? $_POST['title'] : &quot;&quot;;
	}
	$ar = $dacura_server-&gt;importOntology($format, $payload, $entid, $enttitle, $enturl);
	if($ar){
		return $dacura_server-&gt;writeDecision($ar);
		//return $dacura_server-&gt;write_json_result($ont, &quot;Imported Ontology $ont-&gt;id&quot;);
	}
	$dacura_server-&gt;write_http_error();
}

function calculate_dependencies($ontid){
	global $dacura_server;
	$ar = $dacura_server-&gt;calculateOntologyDependencies($ontid);
	if($ar){
		//return $dacura_server-&gt;writeDecision($ar);
		return $dacura_server-&gt;write_json_result($ar, &quot;Calculated dependencies of $ontid&quot;);
	}
	$dacura_server-&gt;write_http_error();	
}

function validate_ontologies(){
	global $dacura_server;
	$json = file_get_contents('php://input');
	$obj = json_decode($json, true);
	if(!$obj or !is_array($obj)){
		$dacura_server-&gt;write_http_error(400, &quot;Communication Error: Update Request lacks a json encoded body&quot;);
	}
	elseif(count($obj) == 0){
		$dacura_server-&gt;write_http_error(400, &quot;No Input: No ontologies have been selected for validation.&quot;);
	}
	elseif(!isset($obj['ontologies']) or !isset($obj['tests'])){
		$dacura_server-&gt;write_http_error(400, &quot;Input Error: both ontologies and tests must be specified.&quot;);
	}
	else {
		$res = $dacura_server-&gt;validateOntologies($obj['ontologies'], $obj['tests']);
		if($res === true){
			return $dacura_server-&gt;write_json_result(&quot;Ontologies validated OK&quot;, &quot;Validated Ontologies&quot;);
		}
		else if(is_array($res)){
			return $dacura_server-&gt;write_json_result($res, &quot;Validated Ontologies&quot;);
		}
		else {
			$dacura_server-&gt;write_http_error();
		}
	}
}

function get_entity_classes(){
	if(isset($_GET['class']) &amp;&amp; isset($_GET['graph'])){
		return get_class_template($_GET['graph'], $_GET['class']);
	}
	else {
		$graphid = isset($_GET['graph']) ? $_GET['graph'] : false;
		global $dacura_server;
		if(!$dacura_server-&gt;schema){
			return $dacura_server-&gt;write_http_error(400, &quot;Get entity classes can only be called in a collection context&quot;);		
		}
		if(isset($_GET['stubs'])){
			$save= isset($_GET['stash']) ? true : false;
			$res = $dacura_server-&gt;getClassFrames($graphid, $save);
		}
		else {
			$res = $dacura_server-&gt;getEntityClasses($graphid);
		}
		if($res){
			return $dacura_server-&gt;write_json_result($res, &quot;Returned entity classes&quot;);		
		}
		else {
			$dacura_server-&gt;write_http_error();
		}
	}
}

function get_class_template($graphid, $classname){
	global $dacura_server;
	//return $dacura_server-&gt;write_http_error(500, $graphid);
	
	if(!$dacura_server-&gt;schema){
		return $dacura_server-&gt;write_http_error(400, &quot;Get entity classes can only be called in a collection context&quot;);		
	}
	$res = $dacura_server-&gt;getClassTemplate($graphid, $classname);
	if($res){
		return $dacura_server-&gt;write_json_result($res, &quot;Returned classe template&quot;);
	}
	else {
		$dacura_server-&gt;write_http_error();
	}	
}


if($dacura_server-&gt;cid() == &quot;all&quot;){
	$entity_type = &quot;ontology&quot;;
}
else {
	$entity_type = &quot;graph&quot;;
}
include_once &quot;phplib/services/ld/api.php&quot;;

/*
getRoute()-&gt;get('/', 'get_schema');

getRoute()-&gt;post('/ontology/(\w+)', 'update_ontology');
getRoute()-&gt;get('/ontology/(\w+)', 'get_ontology');
getRoute()-&gt;post('/ontology/(\w+)', 'update_ontology');
getRoute()-&gt;get('/validate/(\w+)', 'validate_ontology');
getRoute()-&gt;post('/validate_ontologies', 'validate_ontologies');
getRoute()-&gt;get('/(\w+)', 'get_graph');
getRoute()-&gt;post('/(\w+)', 'update_graph');

set_time_limit (0);


/*
 * post requests take input as a application/json

function get_graph($id){
	global $dacura_server;
	$dacura_server-&gt;init(&quot;get_schema&quot;);
	$graph = $dacura_server-&gt;getGraph($id);
	if($graph){
		return $dacura_server-&gt;write_json_result($graph, &quot;Retrieved Graph $id&quot;);
	}
	$dacura_server-&gt;write_http_error();
}

function validate_ontology($ontid){
	global $dacura_server;
	set_time_limit(0);
	
	$res = $dacura_server-&gt;validateOntology($ontid);
	if($res === true){
		return $dacura_server-&gt;write_json_result(&quot;Ontology validated OK&quot;, &quot;Validated Ontology $ontid&quot;);
	}
	else if(is_array($res)){
		return $dacura_server-&gt;write_json_result($res, &quot;Validated Ontology $ontid&quot;);
	}
	$dacura_server-&gt;write_http_error();
}

/*
 * ontology stuff talks to the ld editor

function get_ontology($ontid){
	global $dacura_server;
	set_time_limit(0);
	
	$options = isset($_GET['options']) ? $_GET['options'] : false;
	$version = isset($_GET['version']) ? $_GET['version'] : false;
	$format = isset($_GET['format']) ? $_GET['format'] : false;
	$display = isset($_GET['display']) ? $_GET['display'] : false;
	$dacura_server-&gt;init(&quot;get_ontology&quot;, $ontid);
	$ar = $dacura_server-&gt;getOntology($ontid, $version, $format, $display);
	return $dacura_server-&gt;send_retrieved_entity($ar, $format, $display, $options, $version);
}

function get_ontology_update($update_id){
	global $dacura_server;
	$options = isset($_GET['options']) ? $_GET['options'] : array();
	$version = isset($_GET['version']) ? $_GET['version'] : false;
	$format = isset($_GET['format']) ? $_GET['format'] : false;
	$display = isset($_GET['display']) ? $_GET['display'] : false;
	$dacura_server-&gt;init(&quot;get_ontology_update&quot;, $update_id);
	$ar = $dacura_server-&gt;getUpdate($update_id, $version, $options);
	return $dacura_server-&gt;send_retrieved_update($ar, $format, $display, $options, $version);
}



function update_ontology($target_id,  $fragment_id = false){
	global $dacura_server;
	$ar = new AnalysisResults(&quot;Update Ontology&quot;);
	$json = file_get_contents('php://input');
	$obj = json_decode($json, true);
	if(!$obj){
		$ar-&gt;failure(400, &quot;Communication Error&quot;, &quot;Update Request lacks a json encoded body&quot;);
	}
	elseif($fragment_id){
		//$fragment_id = &quot;local:&quot;.$target_id.&quot;/&quot;.$fragment_id;
		$ar-&gt;failure(403, &quot;Illegal Update&quot;, &quot;Attempt to directly update fragment $fragment_id. Fragments must be updated in context.&quot;);
	}
	else {
		$options = (isset($obj['options'])) ? $obj['options'] : array();
		$test_flag = isset($obj['test']);
		unset($obj['test']);
		unset($obj['options']);
		$ar = $dacura_server-&gt;updateOntology($target_id, $obj, $fragment_id, $options, $test_flag);
	}
	return $dacura_server-&gt;write_decision($ar);
	
}


function update_schema(){
	global $dacura_server;
	$dacura_server-&gt;init(&quot;update_schema&quot;);
	$json = file_get_contents('php://input');
	$ar = new AnalysisResults(&quot;Update Update&quot;);
	$obj = json_decode($json, true);
	if(!$obj){
		$ar-&gt;failure(400, &quot;Communication Error&quot;, &quot;Schema update lacks a json encoded body&quot;);
	}
	else {
		$ar = $dacura_server-&gt;updateSchema($obj, isset($obj['test']));
	}
	return $dacura_server-&gt;write_decision($ar);
}


*/</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>