<html>
    <head>
        <script
            type="text/javascript"
            src="../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
require_once(&quot;ConfigForm.php&quot;);
require_once(&quot;phplib/UserRole.php&quot;);

/**
 * Config Server - provides access to updating / editing / viewing configurations of Dacura collections
 * 
 * Creation Date: 15/01/2015
 *
 * @package config
 * @author chekov
 * @license GPL V2
 */
class ConfigDacuraServer extends DacuraServer {
	
	/**
	 * Creates a new collection .
	 *
	 * @param string $id the requested collection id
	 * @param string $title the requested collection title
	 * @return string|boolean $id the id of the new collection if successful, false otherwise
	 */	
	function createNewCollection($id, $title){
		if(!$this-&gt;isValidCollectionID($id, $title)){
			return false;
		}
		$obj = $this-&gt;getServiceSetting(&quot;default_collection_config&quot;, &quot;{}&quot;);
		$status = $this-&gt;getServiceSetting(&quot;default_status&quot;, &quot;pending&quot;);
		if($this-&gt;dbman-&gt;createNewCollection($id, $title, $obj, $status)){
			if($this-&gt;createCollectionPaths($id)){
				$this-&gt;recordUserAction(&quot;create&quot;, array(&quot;collection&quot; =&gt; $id));
				return $id;
			}
			else {
				return false;				
			}
		}
		else {
			return $this-&gt;failure_result($this-&gt;dbman-&gt;errmsg, $this-&gt;dbman-&gt;errcode);
		}
	}

	/**
	 * Creates the directories required by the collection when it is first created. 
	 * @param string $id the collection id
	 * @return boolean true on success
	 */
	function createCollectionPaths($id){
		$colbase = $this-&gt;getSystemSetting(&quot;path_to_collections&quot;, &quot;&quot;).$id;
		if(file_exists($colbase)){
			return $this-&gt;failure_result(&quot;Collection directory $colbase for collection $id already exists&quot;, 400);				
		}
		if(!mkdir($colbase)){
			return $this-&gt;failure_result(&quot;Failed to create collection directory $colbase for collection $id&quot;, 500);
		}
		$paths_to_create = $this-&gt;getServiceSetting(&quot;collection_paths_to_create&quot;, array());
		foreach($paths_to_create as $p){
			if(!mkdir($colbase.&quot;/&quot;.$p)){
				return $this-&gt;failure_result(&quot;Failed to create collection directory $colbase/$p&quot;, 500);
			}
		}
		if(!$this-&gt;dbman-&gt;createCollectionInitialEntities($id)){
			return $this-&gt;failure_result(&quot;Failed to create collection default linked data entities&quot;, 500);				
		}
		//finally have to create main graph
		return true;
	}
	
	/**
	 * Used to check that the collection's id and password are valid.
	 *
	 * @param string $id the collection id
	 * @param string $title the collection title
	 * @return boolean - true if passed details are valid
	 */
	function isValidCollectionID($id, $title){
		if(!$this-&gt;isValidDacuraID($id)){
			return false;
		}
		elseif($this-&gt;dbman-&gt;hasCollection($id)){
			return $this-&gt;failure_result(&quot;$id is already taken. Two dacura collections cannot share the same ID.&quot;, 400);
		}
		return true;
	}
	
	/**
	 * Assembles the structure for sending the configuration information to the client
	 * @return array (settings, services, collection) = name value arrays with settings for each element
	 */
	function getCollectionConfig(){
		$resp['settings'] = $this-&gt;getSettings();
		$resp['services'] = $this-&gt;getServicesConfig();
		$resp['collection'] = $this-&gt;getCollection();
		return $resp;
	}
	
	/**
	 * Gets the current state of the system settings, 
	 * filtered to remove 'hidden' values so that only those settings that the user is permitted to view are included.
	 * @return array - a json array representing the current system configuration in this context
	 */
	function getSettings(){
		$s = $this-&gt;service-&gt;settings;
		unset($s['config']); //current service's configuration settings are in here
		if($this-&gt;cid() != &quot;all&quot;){
			$sys = $this-&gt;getCollection(&quot;all&quot;);
			$this-&gt;filterHiddenValues($s, $sys-&gt;getConfig(&quot;meta&quot;));
		}
		return $s;
	}
	
	/**
	 * Gets the current state of the service settings for all services 
	 * filtered to remove 'hidden' values so that only those settings that the user is permitted to view are included.
	 * @return array - a json array representing the current services configurations in this context
	 */
	function getServicesConfig(){
		$services = $this-&gt;getServiceList();
		$configs = array();
		$sys = false;
		foreach($services as $s){
			$configs[$s] = $this-&gt;getServiceConfig($s);
			if(!isset($configs[$s]['status'])){
				$configs[$s]['status'] = &quot;enable&quot;;
			}
			if(!isset($configs[$s]['facets'])){
				$configs[$s]['facets'] = array();
			}
			if($this-&gt;cid() != &quot;all&quot;){
				if($sys == false) $sys = $this-&gt;getCollection(&quot;all&quot;);
				$this-&gt;filterHiddenValues($configs[$s], $sys-&gt;getConfig(&quot;servicesmeta.&quot;.$s));
				if($sconf = $sys-&gt;getConfig('services.'.$s)){
					if(isset($sconf['status']) &amp;&amp; $sconf['status'] == &quot;disable&quot;){
						if($this-&gt;userHasFacet(&quot;admin&quot;)){
							$configs[$s]['status'] = 'disable';
						}
						else {
							//if the user is not admin, blank out disabled services
							unset($configs[$s]);
						}
					}
				}
			}
		}
		return $configs;
	}

	/**
	 * Returns an array containing only system level variables (with their default values)
	 * 
	 * Used for distinguishing between collection and system level settings as they are all mixed up in the normal settings variable
	 * @return array the default system configuration settings array (arbitrary json shape)
	 */
	function getSystemLevelSettingsOnly(){
		include(&quot;phplib/settings.php&quot;);
		default_settings($dacura_settings);
		return $dacura_settings;
	}

	/**
	 * Returns the latest log entries as an array 
	 * @return array&lt;logs&gt; an array of logs
	 */
	function getLogsAsListingObject(){
		$this-&gt;recordUserAction(&quot;view logs&quot;);
		return $this-&gt;service-&gt;logger-&gt;lastRowsAsListingObjects();
	}
	
	/**
	 * Filters the current system settings to remove those that have been hidden at a system level
	 * and to remove system level settings from users who do not have the admin facet
	 *
	 * @param array $settings - the name-value settings array
	 * @param array $meta array of meta data about settings, indexed by settingid
	 */
	function filterHiddenValues(&amp;$settings, $meta){
		$sysconf = $this-&gt;getSystemLevelSettingsOnly();
		$can_view_sysconf = $this-&gt;userHasFacet(&quot;admin&quot;) || $this-&gt;userHasFacet(&quot;inspect&quot;);
		foreach($settings as $sid =&gt; $set){
			if(isset($meta[$sid]['changeable']) &amp;&amp; $meta[$sid]['changeable'] == 'hidden'){
				unset($settings[$sid]);
			}
			elseif(!$can_view_sysconf &amp;&amp; isset($sysconf[$sid])){
				unset($settings[$sid]);
			}
			elseif(is_array($set)){
				$this-&gt;filterHiddenValues($settings[$sid], $meta);
			}
		}
	}
	
	/**
	 * Updates the configuration of the collection
	 * 
	 * The collection configuration is described in $obj['settings'] 
	 * while the configuration for each service is in $obj['services'][service_id]
	 * Updates can include settings and/or one or more services - only the included services are updated, the settings is updated
	 * all or nothing.
	 * 
	 * @param string $id the collection id
	 * @param array $obj json version of the configuration settings to be updated
	 * @return array $obj json version of the configuration 
	 */
	function updateCollectionConfig($id, $obj){
		if(!$col = $this-&gt;getCollection($id)){
			return false;
		}
		$upds = array();
		if(isset($obj[&quot;settings&quot;])){
			$uset = $this-&gt;updateSettingsConfig($obj[&quot;settings&quot;]);
			if(count($uset) &gt; 0){
				$upds['settings'] = $uset;
			}
		}
		if(isset($obj[&quot;services&quot;])){
			$usrv = $this-&gt;updateServicesConfig($obj[&quot;services&quot;]);
			if(count($usrv) &gt; 0){
				$upds['services'] = $usrv;
			}	
		}
		if(isset($obj['meta'])){
			$upds['meta'] = $obj['meta'];
		}
		if(isset($obj['servicesmeta'])){
			$upds['servicesmeta'] = $obj['servicesmeta'];
		}
		if(count($upds) == 0){
			return $this-&gt;failure_result(&quot;Submitted update request did not contain any changes to the configuration&quot;, 400);
		}
		if(!$this-&gt;containsOnlyPermittedUpdates($upds)){
			return false;
		}
		$col-&gt;applyUpdate($upds);
		if($ucol = $this-&gt;dbman-&gt;updateCollection($col-&gt;id, $col-&gt;name, $col-&gt;status, $col-&gt;config)){
			$this-&gt;loaded_configs[$id] = $ucol;//refresh cache				
			$resobj = array(&quot;collection&quot; =&gt; $ucol);
			if(isset($upds['services'])){
				$resobj['services'] = $this-&gt;getServicesConfig(); 
			}
			if(isset($upds['settings'])){
				$resobj['settings'] = $this-&gt;getUpdatedSettings();
			}
			$this-&gt;recordUserAction(&quot;update configuration&quot;);				
			return $resobj;
		}
		return $this-&gt;failure_result($this-&gt;dbman-&gt;errmsg, $this-&gt;dbman-&gt;errcode);				
	}
	
	/**
	 * Checks to see whether there are any illegal updates in the object
	 * 
	 * Checks for the following illegal updates:
	 * * config service cannot be disabled
	 * * only platform admin can change /all settings and status of collections
	 * * manage facet is required for all updates
	 * * admin facet is required for overwrites to system settings 
	 * (this is a bit arbitrary, probably not the best way to divide stuff up, but it'll do for the moment)
	 * @param array $upds the update object as filtered by locked and hidden fields....
	 * @return boolean true if there are no illegal updates
	 */
	function containsOnlyPermittedUpdates($upds){
		//config service cannot be disabled
		if(isset($upds['services']['config']) &amp;&amp; isset($upds['services']['config']) 
				&amp;&amp; isset($upds['services']['config']['status']) &amp;&amp; $upds['services']['config']['status'] != &quot;enable&quot;){
			return $this-&gt;failure_result(&quot;Configuration service cannot be disabled.&quot;, 400);
		}
		//only platform admin can change /all settings and status of collections
		if($this-&gt;cid() == &quot;all&quot; || isset($upds['settings']['status'])){
			$u = $this-&gt;getUser();
			if(!$u or !$u-&gt;isPlatformAdmin()) return $this-&gt;failure_result(&quot;Only platform administrators are permitted to carry out that update&quot;, 401);
		}
		//manage facet is required 
		if(!$this-&gt;userHasFacet(&quot;manage&quot;)){
			return $this-&gt;failure_result(&quot;Manage facet is required at a minimum to update collection configuration settings&quot;, 401);
		}	
		//admin facet is required for system settings.
		if(!$this-&gt;userHasFacet(&quot;admin&quot;) &amp;&amp; isset($upds['settings'])){
			foreach($upds['settings'] as $sid =&gt; $sval){
				if($this-&gt;getSystemSetting($sid)){
					return $this-&gt;failure_result(&quot;Manage facet is required at a minimum to update collection configuration setting $sid&quot;, 401);						
				}
			}
		}
		return true;
	}

	/**
	 * Filters the settings aspect of the configuration to only include the actual bits that are being updated
	 * @param array $sets a settings array
	 * @return a settings array, filtered to remove all but the updates
	 */
	function updateSettingsConfig($sets){
		$usets = array();
		foreach($sets as $sid =&gt; $v){
			$current = $this-&gt;getSystemSetting($sid);
			if(is_array($v) &amp;&amp; is_array($current) &amp;&amp; isAssoc($v) &amp;&amp; count($v) &gt; 0 &amp;&amp; isAssoc($current)){
				if(!arrayRecursiveCompare($v, $current)){
					$usets[$sid] = $v;
				}
			}
			elseif(is_array($v) &amp;&amp; is_array($current)){
				if($v != $current){
					$usets[$sid] = $v;
				}
			}
			elseif(!is_array($v) &amp;&amp; !is_array($current)){
				if($current != $v){
					$usets[$sid] = $v;
				}
			}
			else {
				$usets[$sid] = $v;
			}
		}
		if(isset($col-&gt;config['settings'])){
			foreach($col-&gt;config['settings'] as $sid =&gt; $csetting){
				if(!isset($usets[$sid])){
					$usets[$sid] = $csetting;
				}
			}
		}
		return $usets;
	}

	/**
	 * Filters the services configurations to only include the actual bits that are being updated
	 * @param array $sets a services settings array including the data to be updated (services that are not included are ignored)
	 * @return a settings array, filtered to remove all but the updates
	 */
	function updateServicesConfig($srvcs){
		$usets = array();
		foreach($srvcs as $sid =&gt; $ssets){
			$current = $this-&gt;getServiceConfig($sid);
			$usets[$sid] = array();
			foreach($ssets as $k =&gt; $v){
				if(!isset($current[$k])){
					$usets[$sid][$k] = $v;
				}
				else {
					$cval = $current[$k];
					if(is_array($v) &amp;&amp; is_array($cval) &amp;&amp; isAssoc($v) &amp;&amp; count($v) &gt; 0 &amp;&amp; isAssoc($cval)){
						if(!arrayRecursiveCompare($v, $cval)){
							$usets[$sid][$k] = $v;
						}
					}
					elseif(is_array($v) &amp;&amp; is_array($cval)){
						if($v != $cval){
							$usets[$sid][$k] = $v;
						}
					}
					elseif(!is_array($v) &amp;&amp; !is_array($cval)){
						if($cval != $v){
							$usets[$sid][$k] = $v;
						}
					}
					else {
						$usets[$sid][$k] = $v;
					}
				}
			}
			if(isset($col-&gt;config['services'][$sid])){
				foreach($col-&gt;config['services'][$sid] as $cid =&gt; $csetting){
					if(!isset($usets[$sid][$cid])){
						$usets[$sid][$cid] = $csetting;
					}
				}
			}
		}
		return $usets;	
	}
	
	/**
	 * Gets the state of the settings for reporting back immediately after a successful update
	 * The new settings won't take hold until the next call, so we have to load them from file.
	 * @return array a settings array representing the updated state of the settings
	 */
	function getUpdatedSettings(){
		include(&quot;phplib/settings.php&quot;);
		$this-&gt;service-&gt;loadContextSettings($dacura_settings, $this);
		if($this-&gt;cid() != &quot;all&quot;){
			$sys = $this-&gt;getCollection(&quot;all&quot;);
			$this-&gt;filterHiddenValues($dacura_settings, $sys-&gt;getConfig(&quot;meta&quot;));
		}
		return $dacura_settings;
	}
	
	/**
	 * Deletes the collection from the system
	 * @param string $id the collection id
	 * @return boolean if true, the deletion worked
	 */
	function deleteCollection($id){
		if($this-&gt;dbman-&gt;deleteCollection($id, true)){
			$this-&gt;recordUserAction(&quot;delete&quot;);				
			return true;
		}
		return $this-&gt;failure_result($this-&gt;dbman-&gt;errmsg, $this-&gt;dbman-&gt;errcode);
	}
	
	/**
	 * Retrieves the system configuration as an array of DacuraFormElement object initialisation arrays 
	 * 
	 * Uses the passed form element tempaltes where available, otherwise it generates a new form element
	 * This means that whenever a new setting is added, it automatically shows up on the form (albeit in an ugly way)
	 * @param array $sfields the form element templates indexed by arrays 
	 */
	function getSysConfigFields($sfields = array()){
		$ds = $this-&gt;service-&gt;settings;
		unset($ds['config']); //current service's configuration settings are in here
		$cf = new ConfigForm($this);
		return $cf-&gt;getSystemConfigFields($ds, $sfields);		
	}
	

	/**
	 * Retrieves an array of all services configurations each being an array of DacuraFormElement object initialisation arrays
	 *
	 * This means that whenever a new setting is added, it automatically shows up on the form (albeit in an ugly way)
	 * @param array $sfields the form element templates indexed by arrays
	 */	
	function getServicesConfigFields($sfields = array()){
		$sconfigs = array();
		$services = $this-&gt;getServiceList();
		foreach($services as $s){
			$sconfigs[$s] = $this-&gt;getServiceConfigFields($s, isset($sfields[$s]) ? $sfields[$s] : array());
		}
		return $sconfigs;
	}
	
	
	/**
	 * Retrieves a service's configuration as an array of DacuraFormElement object initialisation arrays
	 *
	 * Uses the passed form element templates where available, otherwise it uses the standard elements defined in the services
	 * where available and where not it generates a new form element
	 * This means that whenever a new setting is added, it automatically shows up on the form (albeit in an ugly way)
	 * @param array $sfields the form element templates indexed by arrays
	 */
	function getServiceConfigFields($s, $sfields = array()){
		$configs = $this-&gt;getServiceConfig($s);
		if(isset($configs['config_form_fields'])){
			$nsfields = array_merge($sfields, $configs['config_form_fields']);
		}
		else {
			$nsfields = $sfields;
		}
		$cf = new ConfigForm($this);
		return $cf-&gt;getServiceConfigFields($s, $configs, $nsfields);
	}
}

</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>